# 11 散列表

## 11.1 直接寻址表

### 11.1-1 

> 假设一动态集合 S 用一个长度为 m 的直接寻址表 T 来表示。请给出一个查找 S 中
> 最大元素的过程。你所给的过程在最坏情况下的运行时间是多少？

T[0..m-1] 从下标 m-1 往下标 0 的方向查找第一个不为 NIL 的元素即为最大元素。

最坏的情况是 T 为空，要遍历整个寻址表才能得到结果，运行时间为 O(m)。

### 11.1-2

> 如何用一个位向量来表示一个包含不同元素（无卫星数据）的动态集合。
> 字典操作的运行时间应为 O(1)。

集合中每个元素都不同。用对应位的 bit=1 表示该元素存在。比如有元素为 5，则第 5 个 bit 为 1 。

* 查找操作，即看对应位是否为 1。
* 插入，把对应位置 1
* 删除，把对应位清 0

各操作的运行时间都是 O(1) 。

### 11.1-3

1/ 表里存的是元素指针
2/ 按元素的关键字来决定存到表中哪个位置
3/ 如果遇到关键字相同的元素，则用链表连接

* 查找，按关键字找到表下标，不为 NIL 则返回链表第一个元素
* 插入，插到链表头
* 删除，删除链表头

各操作都是 O(1) 。

### 11.1-4

假设「非常大的数组」是 T。我们需要判断一个元素 k 在不在 T 里。

T 不能被初始化，里面的元素是未知的，什么可能都有。所以我们没办法直接通过 T[k] 的值判断 k 在不在 T 里。

有一个栈 S，它和 T 的关系是  T[k] = j, S[j] = k。初始的时候 S 和 T 都是空的。

1. 插入。往 S 里入栈，S[S.top] = k ，T[k] = S.top
2. 查找。0 < T[k] <= S.top，且 S[T[k]] == k，则说明 k 存在于 T 中
3. 删除。直接删掉 S[T[k]] 会在 S 上留下一个「洞」。解决办法是把栈顶元素填到这个洞里。

删除元素 k 的步骤：

```c
j = T[k]
k1 = S[S.top]
S[j] = k1
T[k1] = j
S.top -= 1
```




