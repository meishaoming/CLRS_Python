# 第2章 算法基础

## 2.1 插入排序

插入排序

```py
def insert_sort(nums):
    for j in range(1, len(nums)):
        key = nums[j]
        i = j-1
        while i >= 0 and nums[i] > key:
            nums[i+1] = nums[i]
            i -= 1
        nums[i+1] = key
    return nums
```

### 2.1-1

> Using Figure 2.2 as a model, illustrate the operation of INSERTION-SORT on the array A=<31, 41, 59, 26, 41, 58>.

<img src="pics/2.1-1.png" width="600">

### 2.1-2

> Rewrite the INSERTION-SORT procedure to sort into nonincreasing instead of non- decreasing order.

```py
def insert_sort_noincrease(nums):
    for j in range(1, len(nums)):
        key = nums[j]
        i = j-1
        while i >= 0 and nums[i] < key:
            nums[i+1] = nums[i]
            i -= 1
        nums[i+1] = key
```

### 2.1-3

```py
def linear_search(nums, target):
    for i, x in enumerate(nums):
        if x == target:
            return i
    return None
```

证明：

1. 初始：在迭代之前，数组就是循环不变体，它初始状态不变
2. 保持：每次迭代时，都不会对数组做任何修改
3. 终止：当搜寻到目标值时，迭代终止，循环不变体没有变化

### 2.1-4

```
形式化描述：

输入：有两个长度为 n 的二进制序列，A=<a1, a2, ..., an>，B=<b1, b2, ..., bn>，其中任意元素ai 和 bi 的值为 0 或 1

输出：长度为 n+1 的序列 C, 满足 C=A+B（各对应位置的元素相加，1+1会有进位）
```

```py
def binary_add(A, B):
    C = [0] * (len(A)+1)
    carry = 0
    for i in range(len(A)-1, -1, -1):
        sum = A[i] + B[i] + carry
        C[i+1] = sum % 2
        carry = sum // 2
    C[i] = carry
    return C
```

## 2.1 分析算法

### 2.2-1

O(n^3)

### 2.2-2

伪代码：

```py
def select_sort(nums):
    for i in range(len(nums)-1):
        min_index = i
        for j in range(i+1, len(nums)):
            if nums[j] < nums[min_index]:
                min_index = j
        nums[i], nums[min_index] = nums[min_index], nums[i]
```

总共有 n 个数，取出 n-1 个最小的数，最后剩下的一个就是最大的数。

循环不变式：每次迭代都是从一个无序列表开始

最好的情况和最坏的情况一样，都需要做 n(n+1)/2 次比较，和 n-1 次交换。运行时间为 O(n^2)。

### 2.2-3

线性查找，假设已排序数组里有一半不比它大，另一半不比它小。那平均要 n/2 步找到目标，记为 O(n/2)。

最坏的情况是目标不在数组里，需要查找 n 次，记为 O(n)。

### 2.2-4

如果只针对「最好情况」做优化，那就考虑在最好的情况下做最少的事情。

对于排序来说，一次遍历能够证明它是已排好序的，运行时间为 O(n)。

## 2.1 设计算法

